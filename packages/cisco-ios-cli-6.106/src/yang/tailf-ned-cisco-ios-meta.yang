module tailf-ned-cisco-ios-meta {

  namespace 'urn:ios-meta';
  prefix cisco-ios-meta;

  import tailf-common {
    prefix tailf;
  }

  import tailf-ncs {
    prefix ncs;
  }

  import ietf-inet-types {
    prefix inet;
  }

  // This import is required when building for CDM style NSOs
  // Is automatically un-commented in  by the NED build system when
  // building for NSO >= 5.0
  //#if (SUPPORTS_CDM == "YES")
  //#replace (//) (  )
  // import cisco-ios-cli {
  //   prefix family;
  // }
  //#endif


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2024-02-20 {
    description "version 6.106, see CHANGES";
  }


  // =========================================================================
  // README NedDocPlugin extension statements
  // =========================================================================
  //

  extension doc-footer-text {
    argument value;
  }
  extension doc-footer-from-file {
    argument value;
  }
  extension doc-custom-text {
    argument value;
  }
  extension doc-new-section {
  }
  extension doc-skip-new-section {
  }
  extension doc-skip {
  }


  // =========================================================================
  // GROUPING
  // =========================================================================


  grouping cisco-ios-ned-settings-grouping {

    // cisco-ios
    container cisco-ios {
      tailf:info "cisco-ios ned-settings";
      description "The following top level ned-settings can be modified";

      // cisco-ios logger
      container logger {
        tailf:info "Settings for controlling logs generated.";

        // cisco-ios logger level
        leaf level {
          tailf:info "Set level of logging";
          description "
            Set NED level of debugging. Warning: If you set the logger level
            to debug, or even to verbose, the logs files may quickly grow very
            large as well as impact the NSO/NED performance.
          ";
          type enumeration {
            enum error;
            enum info;
            enum verbose;
            enum debug;
          }
          default info;
        }

        // cisco-ios logger java
        leaf java {
          tailf:info "Toggle logs to be added to ncs-java-vm.log";
          type boolean;
          default false;
        }
      }

      // cisco-ios extended-parser
      leaf extended-parser {
        tailf:info "Make the cisco-ios NED handle CLI parsing (i.e. transform the "
          +"running-config from the device to the model based config tree)";
        type enumeration {
          enum "disabled" {
            tailf:info "DEPRECATED. Same as robust-mode";
          }
          enum "turbo-mode" {
            tailf:info "The NED executes the whole command parsing by itself, "
              + "completely bypassing the NSO CLI parser. The configuration "
              + "dump is transferred to NSO using maapi setvalues call";
          }
          enum "turbo-xml-mode" {
            tailf:info "The NED executes the whole command parsing by itself, "
              + "completely bypassing the NSO CLI parser. The configuration "
              + "dump is transferred to NSO in XML format";
          }
          enum "robust-mode" {
            tailf:info "Makes the NED filter the configuration so that unmodeled"
              + " content is removed before being passed to the NSO CLI-engine."
              + " This protects against configuration ending up at the wrong"
              + " level when NSO CLI parser fallbacks (which potentially can"
              + " cause following config to be skipped)";
          }
          enum "auto" {
            tailf:info "Uses turbo-mode when available, will use fastest available"
              + "method to load data to NSO. If NSO doesn't support data-loading "
              + "from CLI NED, robust-mode is used.";
          }
        }
        default "auto";
      }

      // cisco-ios connection
      container connection {
        tailf:info "Connection configuration";
        description "
          This section lists the connection ned-settings used when connecting to the device:
        ";

        // cisco-ios connection connector
        leaf connector {
          tailf:info "Change the default connector, e.g. 'ned-connector-default.json'";
          description "
            Change the default connector used for this device, profile or
            global setup. The new connector must be located in the
            src/metadata folder in the NED package, where also the README
            file is located for more information on configuring connectors.
            Default 'ned-connector-default.json'
          ";
          type string {
            tailf:info "WORD;;Connector name (located in src/metadata resources)";
          }
        }

        // cisco-ios connection number-of-retries
        leaf number-of-retries {
          tailf:info "Configure max number of extra retries the NED will try to connect to the device before giving up";
          type uint8 {
            tailf:info "<0-255>;;Connection retry attempts";
            range "0..255";
          }
          default 1;
        }

        // cisco-ios connection time-between-retry
        leaf time-between-retry {
          tailf:info "Configure the time in seconds the NED will wait between each connect retry.";
          type uint8 {
            tailf:info "<1-255>;;Connection retry wait time in seconds";
            range "1..255";
          }
          default 1;
        }

        // cisco-ios connection prompt-timeout
        leaf prompt-timeout {
          tailf:info "Timeout in milliseconds before sending a newline to wake the device (at login only)";
          description "
            This ned-setting can be used to configure a timeout in the
            connection process which can be used to wake the device if the
            device requires additional newlines to be sent before proceeding.
          ";
          type uint32 {
            tailf:info "<0|1000-1000000>;;milliseconds before sending newline. 0 means disabled";
            range "0|1000..1000000" {
              tailf:step 1000;
            }
          }
          default 0;
        }

        // cisco-ios connection send-login-newline
        leaf send-login-newline {
          tailf:info "Send an initial newline in the login phase to wake device [legacy API only]";
          description "
            This ned-setting is used to send an initial newline in the login
            phase, in order to wake the device. This can be usable, for
            example, if the banner config on the device causes the login code
            to miss a prompt.
          ";
          type boolean;
          default false;
        }

        // cisco-ios connection terminal
        container terminal {
          tailf:info "Terminal settings";

          // cisco-ios connection terminal width
          leaf width {
            tailf:info "Terminal width reported by SSH/TELNET upon connect.";
            type uint32;
            default 200;
          }

          // cisco-ios connection terminal height
          leaf height {
            tailf:info "Terminal height reported by SSH/TELNET upon connect.";
            type uint32;
            default 24;
          }

          // cisco-ios connection terminal println-mode
          leaf println-mode {
            tailf:info "Print line mode, i.e. whether to send carriage return and/or newline";
            description "
              This setting controls how the NED feeds lines, i.e. whether to
              send carriage return and/or newline. Typically you may only need
              to modify this setting if you are connecting to the device via a
              terminal server. Four different methods are supported:
             ";
            type enumeration {
              enum "default" {
                tailf:info "System property line.separator default";
              }
              enum "ocrnl" {
                tailf:info "Translate carriage return to newline";
              }
              enum "onocr" {
                tailf:info "Translate newline to carriage return-newline";
              }
              enum "onlret" {
                tailf:info "Newline performs a carriage return";
              }
            }
            default "default";
          }
        }

        // cisco-ios connection ssh
        container ssh {
          tailf:info "Settings related to the SSH client used by the NED";

          // cisco-ios connection ssh client
          leaf client {
            tailf:info "Configure the SSH client to use. Relevant only when using the NED with NSO 5.6 or later.";
            description "
              Specify which SSH client NSO uses to connect to the device as well
              as what SSH implementation the NED will use for SFTP and SCP.
              Two SSH clients are supported:
             ";
            type enumeration {
              enum "ganymed" {
                tailf:info "The legacy SSH client (used on all NSO version older than 5.6)";
              }
              enum "sshj" {
                tailf:info "The new SSH client with support for the latest crypto features (default after NSO version 5.6 or later)";
              }
            }
          }

          // cisco-ios connection ssh keep-alive-interval
          leaf keep-alive-interval {
            tailf:info "Configure SSH client keep alive interval in seconds, default 0";
            type uint32 {
              tailf:info "<0-4294967295>;;SSH client keep alive interval in seconds";
            }
          }
        }
      }

      // cisco-ios proxy
      container proxy {
        tailf:info "cisco-ios proxy ned-settings";
        cisco-ios-meta:doc-custom-text "
          See sections 9, 10 and 11 in README.md for information on proxy ned-settings
          used to connect via a jump host, terminal server or \"exec\" proxy,
          i.e. executing a command/script to connect to device.

          Note: The NED also supports a second jump host by configuring
                'ned-settings cisco-ios proxy2' ned-settings.
        ";
        leaf remote-connection {
          tailf:info "Connection type between proxy and device|proxy2";
          type enumeration {
            enum "exec" {
              tailf:info "master to slave board proxy";
            }
            enum "ssh" {
              tailf:info "SSH jump host proxy";
            }
            enum "telnet" {
              tailf:info "TELNET jump host proxy";
            }
            enum "serial" {
              tailf:info "terminal server proxy";
            }
            enum "ssh-direct" {
              tailf:info "Direct forward to remote SSH server (i.e. without shell on proxy)";
            }
            enum "telnet-direct" {
              tailf:info "Direct forward to remote TELNET server (i.e. without shell on proxy)";
            }
          }
        }
        leaf remote-address {
          tailf:info "Address or hostname of host behind the proxy";
          tailf:display-when "not (../remote-connection='exec')";
          type union {
            type inet:ip-address;
            type inet:host;
          }
        }
        leaf remote-port {
          tailf:info "Port of host behind the proxy";
          tailf:display-when "not (../remote-connection='exec')";
          type uint16;
        }
        leaf remote-command {
          tailf:info "Connection command used to initiate proxy on device. Optional for ssh/telnet. "
            +"Accepts $address, $port, $name for inserting remote-xxx config";
          type string;
        }
        leaf remote-name {
          tailf:info "User name on the device behind the proxy";
          type string;
        }
        leaf remote-password {
          tailf:info "Password on the device behind the proxy";
          type tailf:aes-cfb-128-encrypted-string;
        }
        leaf remote-secondary-password {
          tailf:info "Second password (e.g. enable) on the device behind the proxy";
          type tailf:aes-cfb-128-encrypted-string;
        }
        leaf authgroup {
          tailf:info "Authentication credentials for the device behind the proxy";
          type string {
            tailf:info "WORD;;devices authgroup group";
          }
        }
        leaf remote-prompt {
          tailf:info "Prompt pattern on the remote (proxy) host with remote-conncetion = exec";
          tailf:display-when "../remote-connection='exec'";
          type string;
        }
        leaf proxy-prompt {
          tailf:info "Prompt pattern on the proxy before sending telnet/ssh command";
          type string;
        }
        leaf proxy-prompt2 {
          tailf:info "Prompt pattern on the proxy after sending telnet/ssh command";
          type string;
        }
        container menu {
          tailf:info "Menu choice";
          tailf:cli-compact-syntax;
          leaf regexp {
            tailf:info "Menu regex";
            type string;
          }
          leaf answer {
            tailf:info "Menu answer, i.e. selection/choice";
            type string;
          }
        }
        leaf send-login-newline {
          tailf:info "Send a newline after connected to the proxy to wake up the device for a login prompt";
          type boolean;
          default false;
        }
        leaf remote-ssh-args {
          tailf:info "Optional SSH arguments, appended to end of ssh command line";
          tailf:display-when "not (../remote-command)";
          type string {
            tailf:info "WORD;;optional ssh arguments";
          }
        }
      }

      // cisco-ios proxy2
      container proxy2 {
        tailf:info "cisco-ios proxy ned-settings";
        cisco-ios-meta:doc-skip;
        leaf remote-connection {
          tailf:info "Connection type between proxy2 and device";
          type enumeration {
            enum "ssh" {
              tailf:info "SSH jump host proxy";
              value 1;
            }
            enum "telnet" {
              tailf:info "TELNET jump host proxy";
              value 2;
            }
          }
        }
        leaf remote-address {
          tailf:info "Address of host behind the proxy";
          type inet:ip-address;
        }
        leaf remote-port {
          tailf:info "Port of host behind the proxy";
          type uint16;
        }
        leaf remote-command {
          tailf:info "Connection command used to initiate proxy on device. Optional for ssh/telnet. "
            +"Accepts $address, $port, $name for inserting remote-xxx config";
          type string;
        }
        leaf remote-name {
          tailf:info "User name on the device behind the proxy";
          type string;
        }
        leaf remote-password {
          tailf:info "Password on the device behind the proxy";
          type tailf:aes-cfb-128-encrypted-string;
        }
        leaf remote-secondary-password {
          tailf:info "Second password (e.g. enable) on the device behind the proxy";
          type tailf:aes-cfb-128-encrypted-string;
        }
        leaf authgroup {
          tailf:info "Authentication credentials for the device behind the proxy";
          type string {
            tailf:info "WORD;;devices authgroup group";
          }
        }
        leaf proxy-prompt {
          tailf:info "Prompt pattern on the proxy before sending telnet/ssh command";
          type string;
        }
        leaf proxy-prompt2 {
          tailf:info "Prompt pattern on the proxy after sending telnet/ssh command";
          type string;
        }
        leaf send-login-newline {
          tailf:info "Send a newline after connected to the proxy to wake up the device for a login prompt";
          type boolean;
          default false;
        }
        leaf remote-ssh-args {
          tailf:info "Optional SSH arguments, appended to end of ssh command line";
          tailf:display-when "not (../remote-command)";
          type string {
            tailf:info "WORD;;optional ssh arguments";
          }
        }
      }

      // cisco-ios read
      container read {
        tailf:info "Settings used when reading from device";

        // cisco-ios read transaction-id-method
        leaf transaction-id-method {
          tailf:info "Method used for calculating the transaction id";
          description "
            The method to use by the NED for calculating transaction ID is a
            configurable option. The default method is quite slow since it
            uses output of show running-config and a software calculated
            MD5. The advantage though is that it does not change even if the
            device  reboots. Another advantage is that it works on all
            platforms. If you do not care about the transaction id changing if
            the device reboots you may increase performance significantly by
            changing the method the transaction id is calculated.

            Six different methods are supported:
          ";
          cisco-ios-meta:doc-footer-text "
            Note: 'show config id|history' is not supported on some platforms,
            e.g. 3550, cat4500, cat6500 etc. But if the option is not supported,
            you will get to know this by use of an Exception.
           ";
          type enumeration {
            enum config-hash {
              tailf:info "Calculate MD5 on a snapshot of the entire running config for calculation";
            }
            enum last-config-change {
              tailf:info "Use the 'Last configuration change' timestamp in running config only (WARNING: changed at reboot)";
            }
            enum config-id {
              tailf:info "Use the 'show configuration id' command (WARNING: changed at reboot)";
            }
            enum config-history {
              tailf:info "Use the 'show configuration history' command (WARNING: changed at reboot)";
            }
            enum confd-state-trans-id {
              tailf:info "Use the confd 'show confd-state internal cdb datastore running transaction-id (NETSIM only)";
            }
            enum config-hash-cached {
              tailf:info "DEPRECATED. Same as config-hash since both methods now reuse transaction-id from last show";
            }
            enum config-hash-modeled {
              tailf:info "Same as config-hash except transaction id is only calculated on modeled config";
            }
          }
          default config-hash;
        }

        // cisco-ios read transaction-id-provisional
        leaf transaction-id-provisional {
          tailf:info "Disable use of new NSO feature to set provisional transaction-id in show() to save a call to getTransId() with sync-from";
          description "
           Set to false to disable use of new NSO feature to set provisional
           transaction-id in show() to save a call to getTransId() with
           sync-from.
          ";
          type boolean;
          default true;
        }

        // cisco-ios read show-running-method
        leaf show-running-method {
          tailf:info "Change method to show running-config";
          description "
            Normally the NED uses \"show running-config\" to show configuration.
            This can be changed using this ned-setting, for example:

            devices device cat4500-1 ned-settings cisco-ios read show-running-method
                                          \"show running-config full\"

            Note: For devices which has enabled scp server, this setting can
                  be set to \"scp-transfer\" to use SCP to retrieve
                  running-config. This is slower for small config files but
                  potentially faster for large ones. To debug, run from linux:
                  $ scp -v <username>@<devname>:running-config .

            WARNING: Issues created by use of \"show run all|full\"
                     ARE NOT SUPPORTED due to IOS CLI limitations.
                     Please only use this setting for temporary non-production testing.
          ";
          type string {
            tailf:info "<command> | scp-transfer;;Command/method to get running-config";
          }
          default "show running-config";
        }

        // cisco-ios read replace-config *
        list replace-config {
          tailf:info "Replace (or filter) config when reading from device";
          description "
            The read replace-config list ned-setting can be used to replace or
            filter out config line(s) upon reading from device, i.e. both in a
            sync-from and a config-hash transaction id.

            Apart from the list id, the setting takes one mandatory leaf
            (regex) and two optional (replacement and when):
          ";
          cisco-ios-meta:doc-footer-text "
            An example, on one device the config line \"no service-routing
            capabilities-manager\" kept coming and going due to a service on the
            device. In order to not alter the transaction-id when using
            config-hash the line has to be filtered out. This can be done with
            the following ned-setting:

            devices device dev-1 ned-settings cisco-ios read replace-config filter-sr-cap regexp \"\\nno service-routing capabilities-manager\"

              or for all IOS devices if you want:

            devices global-settings ned-settings cisco-ios read replace-config filter-sr-cap regexp \"\\nno service-routing capabilities-manager\"

            The above ned-setting will result in the line being stripped if available.
            Note how the replacement string is left empty when filtering. This
            means replacing with \"\". Also note how \"\\n\" is needed to identify
            the line starts on a new line as well as needed to strip it and
            avoid a whitespace diff.

            The NED trace (in raw mode) will show the ned-setting in use when
            doing a check-sync or sync-from:

            -- transformed: replaced \"no service-routing capabilities-manager\\r\\n\" with \"\"

            Finally, a word of warning, if you replace or filter out config
            from the show running-config, you most likely will have
            difficulties modifying this config.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf regexp {
            tailf:info "The regular expression (DOTALL) to which the config is to be matched";
            type string {
              tailf:info "WORD;;Regular expression";
            }
          }
          leaf replacement {
            tailf:info "The string which would replace all found matches. May use groups from regex";
            type string {
              tailf:info "WORD;;Replacement entry or leave unset for filtering";
            }
          }
          leaf "when" {
            tailf:cli-drop-node-name;
            type enumeration {
              enum config-only {
                tailf:info "DEPRECATED. Setting it has no effect";
              }
              enum trans-id-only {
                tailf:info "Only replace/filter when calculating transaction id";
              }
            }
          }
        }

        // cisco-ios read inject-config *
        list inject-config {
          tailf:info "Inject config when reading from device";
          cisco-ios-meta:doc-custom-text "
            - read inject-config <id> <regexp> <config> <where>
            - read inject-interface-config <id> <interface> <config>

            The inject-config and inject-interface-config ned-settings can also
            be used to inject config lines when reading from device,
            e.g. parsing show running-config. The injected config is injected
            first or last, or as specified by a DOTALL regexp expression. It
            can also be configured to be inserted after/before each match.

            The inject config settings were implemented to solve cases where
            IOS behaves inconsistently, e.g. hidden defaults which vary from
            device to device, even vary between interfaces types.

            An example:

            interface / logging event link-status is usually shown
            as \"no logging event link-status\" when not set and hidden when
            set. But on a cat4500 it is the reverse: it is shown when set and
            hidden when not set. To solve this one can configure as below:

            To inject 'logging event link-status' on all interfaces (works for
            most device types, hence put globally):

            devices global-settings ned-settings cisco-ios read inject-interface-config \\
              1 interface \".*\" config \"logging event link-status\"

            To inject 'no logging event link-status' on device cat4500 only
            (after the global setting, hence overriding it):

            devices device cat4500 ned-settings cisco-ios read inject-interface-config \\
              1 interface \".*\" config \"no logging event link-status\"

            The two config entries above will solve compare diff problems with
            logging event link-status.

            Another example of config injection use is switchport, which may be
            need to be injected on some devices types. See section 7.

            Here is an example of injecting global config, which will
            be injected at the top level of show running-config:

            devices global-settings ned-settings cisco-ios read inject-config glob
              config \"hostname DEFAULT-HOST-NAME\"

            Global inject config also take an optional 'regexp' string which can
            be used to inject config line(s). The inject can be specified with
           'where' leaf, eight values are supported:

            before-each
              inject command before each matching <config-line>
            before-first
             inject command before first matching <config-line>
            after-each
             inject command after each matching <config-line>
            after-last
             inject command after last matching <config-line>
            before-topmode
             inject command before regex <config-line> topmode
            after-topmode
             inject command after regex <config-line> topmode
            first
             inject command first if regex <config-line> matches or is unset
            last
             inject command last if regex <config-line> matches or is unset

            Here is an example how to inject default-metric after each found
            router eigrp on a cat4500:

            devices device cat4500-1 ned-settings cisco-ios read inject-config eigrp \\
              regexp \"router eigrp (\\\\d+)\" config \" default-metric $1 100 255 1 1500\"

            Up to 9 groups (expr) are supported in the regexp, e.g. $1 - $9.

            Note that in order for the new inject setting to take effect, you
            must disconnect and disconnect. A sync-from is also needed to
            populate NCS/NSO CDB with newly configured injection config.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf regexp {
            tailf:info "Specify where to inject the config with a DOTALL regex [optional]";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Regular expression";
            }
          }
          leaf config {
            tailf:info "Config line(s) that should be injected. May use groups ($1-$9) with regex";
            type string {
              tailf:info "WORD;;Config entry";
            }
          }
          leaf where {
            tailf:cli-drop-node-name;
            type enumeration {
              enum before-each {
                tailf:info "inject command before each matching <config-line>";
              }
              enum before-first {
                tailf:info "inject command before first matching <config-line>";
              }
              enum after-each {
                tailf:info "inject command after each matching <config-line>";
              }
              enum after-last {
                tailf:info "inject command after last matching <config-line>";
              }
              enum before-topmode {
                tailf:info "inject command before regex <config-line> topmode";
              }
              enum after-topmode {
                tailf:info "inject command after regex <config-line> topmode";
              }
              enum first {
                tailf:info "inject command first if regex <config-line> matches or is unset";
              }
              enum last {
                tailf:info "inject command last if regex <config-line> matches or is unset";
              }
            }
          }
        }

        // cisco-ios read inject-interface-config *
        list inject-interface-config {
          tailf:info "Inject config first in interface when reading from device";
          cisco-ios-meta:doc-custom-text "See 'read inject-config' above for information on how to use this ned-setting.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf interface {
            tailf:info "Affected interface(s)";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Regular expression specifying interface";
            }
          }
          leaf "config" {
            tailf:info "Additional config that should be inserted";
            type string {
              tailf:info "WORD;;Config entry";
            }
          }
          // leaf last
        }

        // cisco-ios read snmp-server-user-defaults *
        list snmp-server-user-defaults {
          tailf:info "snmp-server user defaults: auth-password|priv-password";
          description "
            Use this ned-setting to change the default snmp-server user
            passwords to avoid static configration of unknown passwords.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf regexp {
            tailf:info "The regular expression which snmp-server user name must match. Leave unset for all";
            type string {
              tailf:info "WORD;;Regular expression (optional)";
            }
          }
          leaf auth-password {
            tailf:info "The default auth password used for user(s) matching this entry";
            type tailf:aes-cfb-128-encrypted-string {
              tailf:info "WORD;;default snmp-server auth user password";
            }
          }
          leaf priv-password {
            tailf:info "The default priv password used for user(s) matching this entry";
            type tailf:aes-cfb-128-encrypted-string {
              tailf:info "WORD;;default snmp-server priv user password";
            }
          }
        }
      }

      // cisco-ios write
      container write {
        tailf:info "Settings used when writing to device";

        // cisco-ios write memory-method
        leaf memory-method {
          tailf:info "Change method to write config to memory";
          type string {
            tailf:info "WORD;;Command to write config to memory";
          }
          default "write memory";
        }

        // cisco-ios write memory-setting
        leaf memory-setting {
          tailf:info "Configure how and when an applied config is saved"
            +" to persistent memory on the device";
          type enumeration {
            enum on-commit {
              tailf:info "Save configuration immediately after the config"
                +" has been successfully applied on the device. If an error"
                +" occurs when saving the whole running config will be"
                +" rolled back";
            }
            enum on-persist {
              tailf:info "Save configuration during the NED persist handler. Called "
                +"after the config has been successfully applied and commited "
                +"If an error occurs when saving an alarm will be triggered. "
                +"No rollback of the running config is done";
            }
            enum disabled {
              tailf:info "Disable saving the applied config to persistent memory";
            }
          }
          default on-commit;
        }

        // cisco-ios write config-warning *
        list config-warning {
          tailf:info "Device warning regex entry list";
          cisco-ios-meta:doc-custom-text "
            This setting is used to filter, i.e. ignore device output (warnings/errors)

            - write config-warning <regex>

            After having sent a config command to the device the NED will treat
            any text reply as an error and abort the transaction. The config
            command that caused the failed transaction will be shown together
            with the error message returned by the device. Sometimes the text
            message is not an actual error. It could be a warning that should be
            ignored. The NED has a static list of known warnings, an example:

            // general
            \"warning: \\\\S+.*\",
            \"%.?note:\",
            \"info:\",
            \"aaa: warning\",
            \".*success\",
            \"enter text message\",
            \"hqm_tablemap_inform: class_remove error\",

           etc etc.

            If you stumble upon a warning not already in the NED, which is quite
            likely due to the large number of warnings, you can configure the
            NED to ignore them using this ned-setting.

            The list key is a regular expression with a warning that should be
            ignored.

            For example, to add a new warning exception:

             admin@ncs(config)# devices global-settings ned-settings
                 cisco-ios write config-warning \"Address .* may not be up\"
             admin@ncs(config)# commit
             Commit complete.
             admin@ncs(config)# devices device dev-1 disconnect
             admin@ncs(config)# devices device dev-1 connect
             result true
             info (admin) Connected to dev-1

            Note that in order for the warning exception to take effect, you
            must disconnect and connect again, to re-read ned-settings.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key warning;
          leaf warning {
            tailf:cli-multi-word-key;
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Warning regular expression, e.g. vlan.* does not exist.* creating vlan";
            }
          }
        }

        // cisco-ios write config-dependency *
        list config-dependency {
          tailf:info "Add a dynamic diff dependency to solve unsolved dependencies in the NED before next release";
          cisco-ios-meta:doc-custom-text "
            - write config-dependency <id> <mode> <move> <action> <stay>

            This ned-setting can be used to add dynamic dependency rules to
            the NED before being permanently fixed in the NED. This can be
            useful if a dependency bug is found and you do not want to upgrade
            the NED or are in a hurry for the fix.

            Apart from the list id, each ned-setting list entry is configured with:

            mode
             Regex specifying config mode where the rule is checked, don't set
             for top-mode.

            move
             Regex specifying line(s) to move.

            action
             Where to move the line(s). Can be set to before|after|last|first.

            stay
             Regex specifying where 'move' lines will be moved with
             before|after action.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf mode {
            tailf:info "Regex specifying config mode where the rule is checked, don't set for top-mode";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Regex specifying config mode where the rule is checked.";
            }
          }
          leaf move {
            tailf:info "Regex|match-expr specifying line(s) to move";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;regex|match-expr specifying line(s) to move";
            }
          }
          leaf action {
            tailf:cli-drop-node-name;
            type enumeration {
              enum before {
                tailf:info "Move 'move' line(s) before 'stay' line(s)";
              }
              enum after {
                tailf:info "Move 'move' line(s) before 'stay' line(s)";
              }
              enum last {
                tailf:info "Move 'move' line(s) last";
              }
              enum first {
                tailf:info "Move 'move' line(s) first";
              }
            }
          }
          leaf stay {
            tailf:info "Regex|match-expr specifying where 'move' lines will be moved before|after";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Regex|match-expr specifying where 'move' lines will be moved before|after";
            }
          }
          leaf options {
            tailf:info "Optional rule option(s)";
            type string {
              tailf:info "WORD;;Optional rule option(s)";
            }
          }
        }

        // cisco-ios write config-output-max-retries
        leaf config-output-max-retries {
          tailf:info "Maximum number of retries when sending config command to device";
          description "
            This ned-setting is used to configure the maximum number of
            retries when sending config command to device. For example,
            commands like deleting a rd in an ip vrf may sometimes take up to
            70 seconds. The NED will then retry the (next) command once per
            second until the command succeeds or this setting is reached.
          ";
          type uint32 {
            tailf:info "NUM;;Max number of retries when sending config command to device";
          }
          default 180;
        }

        // cisco-ios write config-output-retry-interval
        leaf config-output-retry-interval {
          tailf:info "Interval in milliseconds when retrying config command to device";
          type uint32 {
            tailf:info "Interval in milliseconds when retrying config command to device";
          }
          default 1000;
        }

        // cisco-ios write number-of-lines-to-send-in-chunk
        leaf number-of-lines-to-send-in-chunk {
          tailf:info "Number of commands lines in a chunk sent by the NED"
            + " to the device), NOTE: Only a small set of"
            + " commands can be sent in bulk mode, due to command retries";
          description "
            Some config may be sent in chunks to the device instead of line by line.
            A higher number normally results in better performance but may also have
            a negative impact on the error handling.
            NOTE: If you get an 'Internal ERROR: retry-command', set this setting to
            1 and report the config line which triggered the exception.
          ";
          type uint16 {
            tailf:info "<1-1000>;;Max number of lines per chunk";
            range "1..1000";
          }
          default 100;
        }

        // cisco-ios write device-output-delay
        leaf device-output-delay {
          tailf:info "Delay in milliseconds after each config command output to the device";
          description "
            This ned-setting is used to configure a delay in milliseconds
            after each config command has been sent to the device. This can be
            used to limit the bandwidth or prevent congestion on the
            device.
          ";
          type uint32 {
            tailf:info "NUM;;milliseconds";
          }
          default 0;
        }

        // cisco-ios write inject-command *
        list inject-command {
          tailf:info "Inject command (before or after) specified config-line upon commit";
          cisco-ios-meta:doc-custom-text "
            - write inject-command <id> <config-line> <command> <where>

            The cisco-ios write inject-command ned-setting can be used to inject
            command line(s) in a transaction. This can be needed, for example,
            when deleting crypto config which requires a clear command to be
            run before delete.

            The ned-settings is configured with:

            id
             User defined name for this ned-setting used to identify the list entry

            config-line
             The config line(s) where command should be injected (DOTALL regexp)

            command
             The command (or config) to inject after|before config-line.
             Prefix with 'do ' if you want to run exec command in config mode.
             Prefix with 'exec ' if you want to run exec command in exec mode.

            'where', eight values are supported:
              before-each
               inject command before each matching <config-line>
              before-first
               inject command before first matching <config-line>
              after-each
               inject command after each matching <config-line>
              after-last
               inject command after last matching <config-line>
              before-topmode
               inject command before regex <config-line> topmode
              after-topmode
               inject command after regex <config-line> topmode
              first
               inject command first if regex <config-line> matches or is unset
              last
               inject command last if regex <config-line> matches or is unset

            An example (of a previously hard coded inject case):

             devices global-settings ned-settings cisco-ios write inject-command C1 config-line
              \"no crypto ikev2 keyring \\\\S+\" command \"do clear crypto session\" before-first
             devices global-settings ned-settings cisco-ios write inject-command C2 config-line
              \"no crypto ikev2 keyring \\\\S+\" command \"do clear crypto ikev2 sa fast\" before-first

            The above inject command configs will cause a delete of ikev2 keyring to
            look like this:

             do clear crypto session
             do clear crypto ikev2 sa fast
             no crypto ikev2 keyring XXX

            $i (where i is value from 1 to 9) can also be used to inject
            matches values from the config line. For example:

             devices global-settings ned-settings cisco-ios write inject-command C2 config-line
              \"no interface Tunnel(\\\\d+)\" command \"do clear dmvpn session interface Tunnel $1 static\" before-first

            with a deletion of interface Tunnel100 results in:

             !do clear dmvpn session interface Tunnel 100 static
             no interface Tunnel100

            Hence, $1 is replaced with the first group value from the config line,
            which is (\\\\d+).
";

          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf config-line {
            tailf:info "The config line where command should be injected (DOTALL regex) [optional]";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Config line (regular expression)";
            }
          }
          leaf command {
            tailf:info "The command to inject after|before config-line (start with 'do' if exec command)";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Command line";
            }
          }
          leaf where {
            tailf:cli-drop-node-name;
            type enumeration {
              enum before-each {
                tailf:info "insert command before each matching <config-line>";
              }
              enum before-first {
                tailf:info "insert command before first matching <config-line>";
              }
              enum after-each {
                tailf:info "insert command after each matching <config-line>";
              }
              enum after-last {
                tailf:info "insert command after last matching <config-line>";
              }
              enum before-topmode {
                tailf:info "insert command before regex <config-line> topmode";
              }
              enum after-topmode {
                tailf:info "insert command after regex <config-line> topmode";
              }
              enum first {
                tailf:info "inject command first if regex <config-line> matches or is unset";
              }
              enum last {
                tailf:info "inject command last if regex <config-line> matches or is unset";
              }
            }
          }
        }

        // cisco-ios write replace-commit
        list replace-commit {
          tailf:info "Replace (or filter) config when writing to device";
          cisco-ios-meta:doc-custom-text "
            - write replace-commit <id> <regexp> <replacement>

            The write replace-commit list ned-setting can be used to replace or
            filter out config line(s) upon writing to device.

            Apart from the list id, the setting takes one mandatory leaf and
            one optional:
             regexp
               The regular expression (DOTALL) to which the config is to be
               matched.
             replacement
               The string which would replace all found matches. May use
               groups from regexp. Leave unset for filtering.

            The setting works much like String.replaceAll, i.e. it replaces
            all matches, can use regexp catch groups etc.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf regexp {
            tailf:info "The regular expression (DOTALL) to which the config is to be matched";
            type string {
              tailf:info "WORD;;Regular expression";
            }
          }
          leaf replacement {
            tailf:info "The string which would replace all found matches. May use groups from regex";
            type string {
              tailf:info "WORD;;Replacement entry or leave unset for filtering";
            }
          }
        }

        // cisco-ios write inject-answer *
        list inject-answer {
          tailf:info "Inject answer to question from device received when applying config (commit phase)";
          cisco-ios-meta:doc-custom-text "
            - write inject-answer <id> <question> <answer> <ml-question>

            Some config commands may prompt the CLI for a password, or answer to a
            question. The NED will automatically answer Y(ES) to all such
            standard questions, assuming the config should take effect.

            Some questions though, like password prompts, the NED will not know
            the answer to. In such cases, the NED must be configured with the
            correct answer(s) to a question using the write inject-answer
            ned-setting list.

            The ned-settings is configured with:

            question
              Last line of the device question, regular expression

            answer
              Answer(s) to device question. Separate multiple answers and end
              with \\n.

            ml-question
              Multi-line question, DOTALL regular expression [optional]

            For example, when enabling a pki server config with \"no shutdown\",
            the user must submit a password (twice) the first time. The question
            from the device will look like this:

            %Some server settings cannot be changed after CA certificate generation.
            % Please enter a passphrase to protect the private key
            % or type Return to exit
            Password:

            The password must be submitted twice, hence a second question from
            the device will show once the password is entered the first time:

            Re-enter password:

            Both questions, prompting for the password,  may be answers with a
            single inject-answer entry (note the double \\n below):

            devices device <iosdev> ned-settings cisco-ios write inject-answer A1
                       question \"\\\\APassword:\" answer \"cisco123\\ncisco123\\n\"

            If there are identical password prompts which require different
            passwords, use the ml-question to specify which entry should be used
            for which, e.g.:

            devices device <iosdev> ned-settings cisco-ios write inject-answer A1
                       question \"\\\\APassword:\" answer \"cisco123\\ncisco123\\n\"
                       ml-question \"changed after CA certificate generation\"
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf question {
            tailf:info "Last line of the device question, regular expression";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Question (last line), regex format";
            }
          }
          leaf answer {
            tailf:info "Answer(s) to device question";
            type string {
              tailf:info "WORD;;Answer(s) to device question, use \\n for newline";
            }
          }
          leaf ml-question {
            tailf:info "Multi-line question, DOTALL regular expression [optional]";
            type string {
              tailf:info "WORD;;Multi-line question, DOTALL regex format";
            }
          }
        }

        // cisco-ios write transfer-via-file
        leaf transfer-via-file {
          tailf:info "Set to true with NETSIM to optimize config transfer via file in /tmp directory";
          description "
            This ned-setting is used with NETSIM device only to optimize the
            file transfer by use of a temporary file located in the /tmp
            directory. Do not enable unless you got a writeable /tmp
            directory.
          ";
          type boolean;
          default false;
        }

        // cisco-ios write apply-reboot-timer
        leaf apply-reboot-timer {
          tailf:info "Enable reboot timer when applying config and device not responding, set in minutes or 0 to disable [EXPERIMENTAL]";
          description "
            This ned-setting is used with development mainly and can be
            useful if you happen to commit config which disconnects your
            access to the device. If set, the NED will set the reboot (reload)
            timer before sending config to the device, and cancel it
            afterwards; making the device automatically reboot if you loose
            connection to the device.
          ";
          type uint16 {
            tailf:info "<0|2|3|4|9|19|29|39|49|59>;;Minutes to device reboot if no response from device during apply phase";
            range "0|2|3|4|9|19|29|39|49|59";
          }
          default 0;
        }

        // cisco-ios write config-revert-timer
        leaf config-revert-timer {
          tailf:info "Enable use of configure revert idle timer to detect loss of connection. Requires archive config on device";
          description "
            Set this ned-setting to a non-zero value to enable use of built-in
            'config t revert timer idle <minutes>' feature in IOS, triggering
            a rollback to last archived config with loss of connection after
            <minutes>. The NED will be notified of a loss of connection using
            the read-timeout timer. For best result, set device read-timeout
            to a value close to this timer or the device may rollback unexpectedly.
            Finally, the feature is temporarily disabled when 'archive' config
            is included in the commit, to allow user to initialize the device
            before use.
          ";
          type uint8 {
            tailf:info "<0-120>;;maximum number of minutes idle while sending config. Used to detect loss of connection. 0 = disabled";
            range "0..120";
          }
          default 0;
        }

        // cisco-ios write ignore-abort-errors
        leaf ignore-abort-errors {
          tailf:info "Set to true to ignore errors in abort phase.";
          type boolean;
          default false;
        }

        // cisco-ios write config-archive *
        list config-archive {
          tailf:info "Contains settings used for config backup on device on commit";
          cisco-ios-meta:doc-custom-text "
            When config-archive is configured IOS NED will save running-configuration into file(s) on device.

            The running-configuration is copied after NED performs 'write memory'.

            The errors during copy, if any, should be ignored (with log entry), hence if a copy operation
            fails the transaction proceeds to success, and any subsequent copy operations are attempted.
            The transaction succeeds even when all copy operations fail.
            Each list entry, unless disabled, will result in a copy operation.

            The copy operation is performed as 'copy /noverify running-config url'

            The url for destination is formed in the following manner:
            1. Substitution is performed on filename:
                     %h is replaced with device name, which is NSO /devices/device/name
                     %d is replaced with NSO system date in YYYY-MM-DD format
                     %t is replaced with NSO system time in hh:mm:ss format
                     %i is replaced with NSO Maapi transaction id
               Each of substituional sequences is optional.  The sequences can appear in any order.

               For example following filenames are valid:
                 config_backup.txt
                 config_backup_%h.txt
                 config_backup_%h_%i.txt
                 config_backup_%h_%dT%t_%i.txt
                 %i_%d_%h.txt

            2. If type = 'remote' and remote-user or remote-user and remote-password specified,
               substitution is performed on directory by splicing in user/password, e.g.
                 directory    scp://server.examle.com/
                 remote-user  archiveuser
                 remote-user  archivepassword
                 result       scp://user:password@server.examle.com/

            3. Result of directory and filename substitution joined together to form target url

               The NED does not verify resulting url for validity.

          NED does not create directories, hence the copy operation will fail if directory does not exist.
          The copy destination can be local or remote.
          Remote destinations support addition of remote-user/remote-password described above.

          Local destinations support following additional features:

                Maximum files:

                After the copy operation completes, NED will:

                  1. Perform directory listing on the device
                       dir directory

                  2. If the directory contains more then max-files files, NED will remove oldest files,
                     so that only max-files are left in the directory
                       delete /force directoryAndOldFileName

                If max-files is configured, it is critical that the directory is dedicated to keeping
                the archive, otherwise non-archive files may be removed.  This is especially dangerous
                if the directory is committed all together or points to the root of local system, which
                will lead to removal of ios image and startup configuraiton files.
        ";
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;The ID of config-archive entry";
            }
          }
          leaf disabled {
            tailf:info "Disable archiving for specific list entry";
            type boolean;
            default false;
          }
          leaf type {
            tailf:info "Type of target local/remote.  Local archiving has additional features.";
            type enumeration {
              enum "local" {
                tailf:info "Local storage, e.g. disk0: flash: harddisk:";
              }
              enum "remote" {
                tailf:info "Remote storage (e.g. using ftp: scp: tftp:)";
              }
            }
            default local;
          }
          leaf directory {
            tailf:info "URI for target directory, e.g. flash:/archive/";
            type string;
          }
          leaf filename {
            tailf:info "Filename, use %h,%d,%t,%i for substitution";
            type string;
          }
          leaf remote-user {
            when "../type = 'remote'";
            tailf:info "Specify user name device will use to access remote file system";
            type string;
            description "User name";
          }
          leaf remote-password {
            when "../type = 'remote'";
            tailf:info "Specify password device will use to access remote file system";
            tailf:suppress-echo "true";
            type tailf:aes-cfb-128-encrypted-string;
            description "Password";
          }
          leaf max-files {
            when "../type = 'local' and ../directory and (../directory != '/' and ../directory != 'flash:/' and ../directory != 'disk0:/' and ../directory != 'disk1:/' and ../directory != 'flash:' and ../directory != 'disk0:' and ../directory != 'disk1:' and ../directory != 'flash-1:' and ../directory != 'flash-1:/' and ../directory != 'flash-2:' and ../directory != 'flash-2:/' and ../directory != 'usbflash0:' and ../directory != 'usbflash0:/' and ../directory !='usbflash0-1:' and ../directory != 'usbflash0-1:/' and ../directory != 'usbflash0-2:' and ../directory != 'usbflash0-2:/' and ../directory !='harddisk:' and ../directory != 'hardisk:/' and ../directory != 'bootdisk:' and ../directory != 'bootdisk:/' and ../directory != 'bootflash:' and ../directory != 'bootflash:/' )";
            tailf:info "Maximum number of files to keep on local storage";
            type uint16 {
              range "1..1000";
            }
          }
        }
      }

      // auto - container for dynamic behaviour
      container auto {
        tailf:info "Configure auto (dynamic behaviour) when reading or writing from|to device";

        // cisco-ios auto vrf-forwarding-restore
        leaf vrf-forwarding-restore {
          tailf:info "Restore interface ip address after vrf forwarding change (write)";
          description "
            This setting can be used to disable the NED automatic behaviour or
            restoring the interface addresses on the device when vrf is
            changed (deleted or set) on an interface.
          ";
          type boolean;
          default true;
        }

        // cisco-ios auto ip-vrf-rd-restore
        leaf ip-vrf-rd-restore {
          tailf:info "Restore ip vrf route-targets when ip vrf rd change (write)";
          description "
            This setting can be used to disable the NED automatic behaviour or
            restoring the route-targets on the device when rd is changed in an
            ip vrf.
          ";
          type boolean;
          default true;
        }

        // cisco-ios auto ip-community-list-repopulate
        leaf ip-community-list-repopulate {
          tailf:info "Restore ip community-list after delete of individual entry (for cat3550) (write)";
          type boolean;
          default false;
        }

        // cisco-ios auto interface-switchport-status
        leaf interface-switchport-status {
          tailf:info "Auto set interface switchport status using 'show interface <name> switchport (read)";
          description "
            This ned-setting is used to auto inject 'switchport' or 'no
            switchport' when reading Ethernet or Port-channel switchport
            status. If enabled, the NED will execute a \"show int <interface>
            switchport\" to determine if switchport is enabled or not on the device.

            WARNING: Enabling this option downgrades performance. For optimal
            performance, see section 12. Fixing switchport issues .. in README.md
          ";
          type boolean;
          default false;
        }

        // cisco-ios auto if-switchport-sp-redeploy
        leaf if-switchport-sp-redeploy {
          tailf:info "Redeploy service-policy input|output when toggling switchport in interface (write)";
          type boolean;
          default true;
        }

        // cisco-ios auto if-switchport-sp-patch
        leaf if-switchport-sp-patch {
          tailf:info "Auto-inject explicit delete of service-policy input|output when toggling switchport in interface (fixes me3600 issue) (write)";
          type boolean;
          default false;
        }

        // cisco-ios auto if-address-delete-patch
        leaf if-address-delete-patch {
          tailf:info "Pre-inject interface shutdown or address delete in order to solve dependency issues (write)";
          type boolean;
          default true;
        }

        // cisco-ios auto bgp-nbr-password-patch
        leaf bgp-nbr-password-patch {
          tailf:info "Pre-inject dummy 0 password in router bgp neighbors to solve password not set (write)";
          type boolean;
          default true;
        }

        // cisco-ios auto use-ip-mroute-cache-distributed
        leaf use-ip-mroute-cache-distributed {
          tailf:info "Send 'ip mroute-cache distributed' instead of 'ip mroute-cache' (write)";
          cisco-ios-meta:doc-footer-text "
            Note: cat3560/3750 allow 'ip mroute-cache distributed'
            cat4506 allows 'ip mroute-cache'
            Both just shows 'ip mroute-cache' in show running-config.
          ";
          type boolean;
          default false;
        }

        // cisco-ios auto compress-spanning-tree-vlan
        leaf compress-spanning-tree-vlan {
          tailf:info "Set to true if want the NED to compress delete|create of 'spanning-tree vlan' (write)";
          type boolean;
          default false;
        }

        // cisco-ios auto stackwise-virtual-if-indent-patch
        leaf stackwise-virtual-if-indent-patch {
          tailf:info "Set to false if you want to disable the stackwise-virtual interface left-indent patch (read)";
          type boolean;
          default true;
        }

        // cisco-ios auto cdp-read-inject
        leaf cdp-read-inject {
          tailf:info "Enable auto-inject of 'no cdp run' and 'interface <regex> / no cdp enable' for devices with CDP disabled by default (read)";
          description "
            Enable auto-inject of 'no cdp run' and 'interface <regex> / no cdp
            enable' for devices with CDP disabled by default (read).

            set regex to enable and specify which interface(s) to inject 'no cdp enable' in.
          ";
          type string {
            tailf:info "WORD;;Set regex to enable and specify which interface(s) to inject 'no cdp enable' in";
          }
        }

        // cisco-ios auto interface-range-write
        leaf interface-range-write {
          tailf:info "Enable use of 'interface range' config command when modifying|creating interface config (write)";
          description "
            Enable use of 'interface range' config command when modifying
            multiple existing interfaces with the same sub-mode config.
            Notice: for some obscure reason IOS does not allow service
            instance to be modified with interface range command, hence
            interfaces with such config modifications are excluded from this
            feature.
          ";
          type boolean;
          default false;
        }

        // cisco-ios auto disable-config-lock-if-sp
        leaf disable-config-lock-if-sp {
          tailf:info "Disable interface service-policy config locks (warning: IOS version specific)";
          type boolean;
          default false;
        }
      }

      // cisco-ios api
      container api {
        tailf:info "Configure API (new API features/changes)";

        // cisco-ios api police-format
        leaf-list police-format {
          tailf:info "Configure the format(s) used by the device for police settings";
          description "
            There are a number of different formats used among IOS devices
            for police configurations.

            The NED usually is able to auto detect the correct format to use.
            However, in some cases it is necessary to configure this manually.
            For instance when connecting the NED to a new type of IOS device.

            Five different settings are possible:
          ";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum "auto" {
              tailf:info "Let the NED probe the device for the correct format";
            }
            enum "cirmode" {
              tailf:info "police cir <bps> [[bc <burst-normal>] [be <burst-max>]]"
                +"[pir <bps> [be <burst-bytes>]] ACTIONS";
            }
            enum "bpsflat" {
              tailf:info "police <bps> bps <byte> byte ACTIONS";
            }
            enum "numflat" {
              tailf:info "police <bps> <burst> exceed-action {drop | policed-dscp-transmit}]";
            }
            enum "cirflat" {
              tailf:info "police cir <bps> bc <burst-normal> ACTIONS";
            }
          }
        }

        // cisco-ios api new-ip-access-list
        leaf new-ip-access-list {
          tailf:info "Use the new combined ip access-list with sequence numbers only (method 2)";
          description "
            This ned-setting is used to switch to the new improved 'ip access'
            YANG API which orders access-list entries on the sequence number
            instead of the rule line. See tailf-ned-cisco-ios.yang for syntax.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api access-list-resequence
        leaf access-list-resequence {
          tailf:info "Use resequence for ip and ipv6 access-list handling (method 3)";
          description "
            This ned-setting is used to switch to the third method of configuring
            ip access-list extended, allowing for moving or inserting new entries
            without removing the current entries like the default method must do.

            Make sure the device does not have 'ip access-list persistent' set.
            Do not use access-list sequence numbers in NSO (or on the device). The NED
            will dynamically use the sequence numbers when inserting/moving access-list
            entries by starting of with a 'ip access-list resequence' command.
            To understand the new YANG model, set the access-list(s) on the device and
            sync-from to NSO, and/or grep the YANG file for 'resequence'.

            NOTES: - remark entries are not supported due to IOS does not number them.
            - ipv6 is not supported due to lack of ipv6 resequence command.
            - standard ip access-list not supported due to device not ordering
              the lists using the sequence number, entries always added last.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api acl-resequence-range
        leaf acl-resequence-range {
          tailf:info "Used with 'acl-resequence-range' to set resequence range";
          type uint32 {
            tailf:info "<1-2147483647>;;Resequence range.";
            range "1..2147483647";
          }
          default 1000;
        }

        // cisco-ios api unordered-ip-access-list-regex
        leaf unordered-ip-access-list-regex {
          tailf:info "Specify which access-list entries should be stored in unordered list";
          description "
            Specify which access-list entries should be stored in unordered
            list. To use:

            1) - Configure a regex (excluding braccets) specifying which lists should
                 should reside in the unordered extended list, e.g.:
                 ned-settings cisco-ios api unordered-ip-access-list-regex \"UNORDERED.+\"

                 Note: The NED will add the unordered keyword if list matches the regex
                       when reading from the device.

            2) - Configure the accesss-list in ip/access-list/unordered list
                 Note: when NED commits the list, it will strip the unordered keyword.
          ";
          type string {
            tailf:info "WORD;;regex specifying which access-lists should be stored in unordered list";
          }
        }

        // cisco-ios api new-snmp-server-host
        leaf new-snmp-server-host {
          tailf:info "Use the new snmp-server host list with support for multiple community strings";
          description "
            This ned-setting is used to switch to the new improved 'snmp-server host'
            YANG API which allows multiple community strings. See YANG for syntax.
            NOTE: New api requires 'traps' or 'informs' due to YANG limitations.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api aaa-accounting-mode-format
        leaf aaa-accounting-mode-format {
          tailf:info "Enable the newer aaa accounting mode format.";
          description "
            Enable the newer aaa accounting mode format. Set to automatically
            transform output of aaa accounting to the newer mode format syntax.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api aaa-accounting-dot1x-mode-format
        leaf aaa-accounting-dot1x-mode-format {
          tailf:info "Override the general aaa accounting mode format ned-setting for dot1x only";
          type boolean;
        }

        // cisco-ios api expanded-line-vty-format
        leaf expanded-line-vty-format {
          description "
            Set this ned-setting to true to support individual editing of
            'line vty <start> <end>' entries in show running-config. This will
            fix all issues with overlapping line vty entries in show running.
            Note: when this ned-setting is set to true, then the dual-key line vty
            list is disabled and only the 'vty-single-conf' line is used.
          ";
          tailf:info "Disable the 2 key line vty list and only use the vty-single-conf list. Expand line vty ranges when reading";
          type boolean;
          default false;
        }

        // cisco-ios api pretty-line-vty-format
        leaf pretty-line-vty-format {
          tailf:info "Use with api/expanded-line-vty-format to format commit for pretty print in line vty show run";
          description "
            Set this ned-setting to true to format commit for pretty print in
            line vty 'show run' on device.  More specifically, it will extract
            identical line vty passwords and commit in a single range to avoid
            the device encrypting them with different IV's.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api new-mls-qos
        leaf new-mls-qos {
          tailf:info "Switch to use the new mls qos API, supporting duplicate values in 'mls qos map cos-dscp'";
          type boolean;
          default false;
        }

        // cisco-ios api ios-common
        leaf ios-common {
          tailf:info "Enable to unify some of IOS API discrepancies. See README for list";
          description "
            Enable this ned-setting to unify some of IOS API discrepancies. The NED
            will auto-correct differences when reading from device. In order to avoid
            configuration diff, you must only use ONE API in the NED.

            Currently affected API's are:

            'logging *' and 'logging host *'     - Use 'logging *' list only.

             WARNING: Changing the above ned-settings will most likely affect the YANG model.
          ";
          type boolean;
          default false;
        }

        // cisco-ios api snmp-server-enable-all-traps
        leaf snmp-server-enable-all-traps {
          tailf:info "Enable the all-traps API. Set to > 0 for minimum traps, < 0 for max missing traps and 0 to disable";
          description "
            Set to non-zero value to treat all 'snmp-server enable traps' as one 'all-traps'
            leaf i.e. 'snmp-server enable all-traps' instead of individual ones in a list.
            Set to negative or positive value, representing two different variants:
            (1) set to a positive value for minimum amount of traps on device
            (2) set to a negative value for maximum missing, i.e. -1 = no missing traps
            Hence, if the above condition is met, the all-traps leaf is set in show().
          ";
          type int32;
          default 0;
        }

        // cisco-ios api new-aaa-list-syntax
        leaf new-aaa-list-syntax {
          tailf:info "Switch to use the new aaa authorization syntax, supporting user ordering of config items";
          type boolean;
          default false;
        }

        // cisco-ios api class-map-match-multi-line-format
        leaf class-map-match-multi-line-format {
          tailf:info "Switch to use multi-line format for class-map / match dscp|precedence statements";
          type boolean;
          default false;
        }
      }

      // cisco-ios live-status
      container live-status {
        tailf:info "Configure NED settings related to live-status";

        // cisco-ios live-status time-to-live
        leaf time-to-live {
          tailf:info "Define time-to-live for data fetched from the device via live-status";
          type int32;
          default 50;
        }

        // cisco-ios live-status exec-done-pattern
        leaf exec-done-pattern {
          tailf:info "A regular expression used to tell the NED the exec command has completed."
            +" Can be used when the exec command does not end with a device prompt";
          description "
            This ned-setting can be used when the exec command does not end with
            a device prompt. If the regexp is matched, the NED will return all
            text up to and including this regexp. The default setting is set to
            the output of the \"issu runversion\" command:
            \"(Initiating active RP failover)|(Target RP will now reload)\"
          ";
          type string {
            tailf:info "WORD;;Regular expression";
          }
        }

        // cisco-ios live-status exec-strict-prompt
        leaf exec-strict-prompt {
          tailf:info "Set prompt <regex> to enable strict prompt matching for live-status commands."
            +" %p = device prompt (auto-retrieved by sending newline)";
          description "
            This ned-setting can be used to enable to enable stricter prompt
            matching for 'live-status exec any' commands. Setting it to include
            %p will make the NED send an initial newline to determine the device
            prompt, there after use that exact prompt in the following command(s).
          ";
          type string {
            tailf:info "WORD;;Set prompt <regex> to enable strict prompt, e.g. '\\A%p$'";
          }
        }

        // cisco-ios live-status template-root
        leaf template-root {
          tailf:info "GILI template root, for template debugging, e.g. '/tmp/gili'";
          description "
            This is ned-setting is used to debug GILI templates under
            development. Set to an external directory where you store your
            GILI templates (normally under <ned>/src/gili. The advantage
            of an external directory is (1) you do not have to re-build the
            package each time you change a template and (2) templates in
            external directory are never cached by the NED, hence can be
            modified while testing in ncs_cli.
          ";
          type string {
            tailf:info "WORD;;Path to GILI templates";
          }
        }

        // cisco-ios live-status auto-prompts *
        list auto-prompts {
          tailf:info "Pre-stored answers to device prompting questions";
          cisco-ios-meta:doc-custom-text "
            See section 5. Built in live-status actions in README.md for information
            on how to use this ned-setting.
          ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          ordered-by user;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;List id, any string";
            }
          }
          leaf question {
            tailf:info "Device question, regular expression";
            type string {
              tailf:info "WORD;;Question, regex format";
            }
          }
          leaf answer {
            tailf:info "Answer to device question";
            type string {
              tailf:info "WORD;;Answer to device question or the word 'ENTER' for LF+CR";
            }
          }
        }

        // cisco-ios live-status always-show-exec-command
        leaf always-show-exec-command {
          tailf:info "Normally sent command is only shown if multiple commands are sent using ';' delimiter in "
            +"'live-status exec any' action. But if this setting is set to true, single commands are also shown.";
          type boolean;
          default false;
        }
      }

      // cisco-ios developer
      container developer {
        tailf:info "Contains settings used by the NED developers";

        // cisco-ios developer prepare-dry-model
        leaf prepare-dry-model {
          tailf:info "Specify temporary device model for prepare-dry output";
          type string {
            tailf:info "WORD;;Device model (from devices/device/platform)";
          }
        }

        // cisco-ios developer progress-verbosity
        leaf progress-verbosity {
          tailf:info "Maximum NED verbosity level reported by the NED.";
          type enumeration {
            enum disabled {
              value -1;
            }
            enum normal {
              value 0;
            }
            enum verbose {
              value 1;
            }
            enum very-verbose {
              value 2;
            }
            enum debug {
              value 3;
            }
          }
          default debug;
        }

        // cisco-ios developer trace-timestamp
        leaf trace-timestamp {
          tailf:info "Add timestamp from NED instance in trace messages for debug purpose";
          type boolean;
          default false;
        }

        // cisco-ios developer trace-level
        leaf trace-level {
          tailf:info "DEPRECATED and not used";
          cisco-ios-meta:doc-skip;
          type uint8 {
            range "6..9";
          }
          default 6; // info
        }

        // cisco-ios developer trace-connection
        leaf trace-connection {
          tailf:info "Enable connection tracing. WARNING: may choke NSO with IPC messages";
          type boolean;
          default false;
        }

        // cisco-ios developer simulate-show *
        list simulate-show {
          tailf:info "Used with live-status to inject simualted output for a show command";
          tailf:cli-suppress-mode;
          key cmd;
          leaf cmd {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Full show command, e.g. 'show version'";
            }
          }
          leaf file {
            type string {
              tailf:info "WORD;;Path to file containing output of simulated show command";
            }
          }
        }

        // cisco-ios developer failphase
        leaf failphase {
          tailf:info "For internal debugging, do not set";
          type string {
            tailf:info "WORD;;For internal debugging, do not set";
          }
          default "";
        }

        // cisco-ios developer extended-parser-fallback
        leaf extended-parser-fallback {
          tailf:info "Fallback to NSO parser upon Exception in turbo extended-parser.";
          type boolean;
          default true;
        }

        // cisco-ios developer fail is-alive
        container fail {
          tailf:info "Simulate failures";
          leaf is-alive {
            tailf:info "Simulate isAlive() method returns false to trigger device reconnect";
            type uint32 {
              tailf:info "uint32;;number of times isAlive() method will return true before false, 1 = first time";
            }
            default 0;
          }
        }

        // cisco-ios developer disable-config-locks
        leaf disable-config-locks {
          tailf:info "Disable config locks. WARNING: Some commits must be split into two commits with locks disabled";
          type boolean;
          default false;
        }

        // cisco-ios developer trace-enable
        leaf trace-enable {
          cisco-ios-meta:doc-skip;
          status deprecated;
          tailf:hidden all;
          tailf:info "DEPRECATED, set 'logger level' to 'debug' instead. Warning: may spam trace";
          type boolean;
          default false;
        }

        // cisco-ios developer load-native-config
        container load-native-config {
          tailf:info "Settings for load-native-config";

          // cisco-ios developer load-native-config allow-delete
          leaf allow-delete {
            tailf:info "Enable this setting to be able to handle limited delete operations with 'load-native-config'. Please note that not all syntax available on a real device works, some delete operations can not be parsed by the NED. Use the 'verbose' flag to 'load-native-config' to see if delete commands can be parsed. Currently this is only supported when 'extended-parser' is set to 'turbo-xml-mode'";
            type boolean;
            default false;
          }

          // cisco-ios developer load-native-config delete-with-remove
          leaf delete-with-remove {
            when "../allow-delete = 'true'";
            tailf:info "Enable this setting to use 'remove' instead of 'delete' when sending delete operations to NSO. This is useful when doing delete commands for data that might not be present in CDB. Please note that deletes for missing data will still be part of transaction, and will be sent to device. Use with care, and do proper testing to understand behaviour";
            type boolean;
            default false;
          }
        }
      }

      // cisco-ios deprecated
      container deprecated {
        tailf:info "Deprecated ned-settings";
        cisco-ios-meta:doc-skip;

        // cisco-ios deprecated cached-show-enable
        container cached-show-enable {
          tailf:info "Enable cached-show [DEPRECATED]";

          // cisco-ios deprecated cached-show-enable version
          leaf version {
            tailf:info "Enable caching of some output of 'show version' command [DEPRECATED]";
            type boolean;
            default false;
          }

          // cisco-ios deprecated cached-show-enable inventory
          leaf inventory {
            tailf:info "Enable caching of the physical inventory [DEPRECATED]";
            type boolean;
            default false;
          }
        }
      }

      // DEPRECATED: cisco-ios log-verbose
      leaf log-verbose {
        cisco-ios-meta:doc-skip;
        status deprecated;
        tailf:hidden all;
        tailf:info "DEPRECATED, set 'logger level' to 'verbose' instead";
        type boolean;
        default false;
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// ned-settings
  /// ========================================================================

  augment "/ncs:devices/ncs:global-settings/ncs:ned-settings" {
    uses cisco-ios-ned-settings-grouping;
  }

  augment "/ncs:devices/ncs:profiles/ncs:profile/ncs:ned-settings" {
    uses cisco-ios-ned-settings-grouping;
  }

  augment "/ncs:devices/ncs:device/ncs:ned-settings" {
    // Different 'when' expressions used when building for NSOs with and without CDM support.
    // The NED build system will automatically 'uncomment' the right one.
    // CDM style syntax:
    //#if (SUPPORTS_CDM == "YES")
    //#replace (//) (  )
    //when "derived-from(../ncs:device-type/ncs:cli/ncs:ned-id,'family:cisco-ios-cli')";
    //#else
    when "../ncs:device-type/ncs:cli/ncs:ned-id = 'ios-id:cisco-ios'";
    //#endif

    uses cisco-ios-ned-settings-grouping;
  }
}
